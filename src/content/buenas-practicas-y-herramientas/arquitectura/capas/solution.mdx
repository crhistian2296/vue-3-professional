## Solución propuesta: separación por capas

A continuación se muestra una posible organización en cuatro capas (delivery, domain, application, infrastructure) tomando como base el ejercicio de repositorio para TODOs.

### Estructura de carpetas sugerida

```
capas/
├─ delivery/
│  └─ TodosView.vue
├─ domain/
│  ├─ todo.ts
│  └─ todo.repository.ts
├─ application/
│  └─ get-todos.qry.ts
├─ infrastructure/
│  ├─ http-client.ts
│  └─ todo-api.repository.ts
└─ container.ts
```

---

### domain/todo.ts

```ts
// Entidad de dominio. No depende de Vue ni de HTTP ni de nada "externo".
export interface Todo {
  userId: number
  id: number
  title: string
  completed: boolean
}
```

### domain/todo.repository.ts

```ts
// Contrato de dominio para obtener todos
// import type { Todo } from './todo'

export interface Todo {
  userId: number
  id: number
  title: string
  completed: boolean
}

export interface TodoRepository {
  findAll(): Promise<Todo[]>
}
```

---

### infrastructure/http-client.ts

```ts
// Abstracción mínima de cliente HTTP
export interface HttpClient {
  get<T>(url: string): Promise<T>
}

export class FetchHttpClient implements HttpClient {
  constructor(private readonly baseUrl: string) {}

  async get<T>(url: string): Promise<T> {
    const res = await fetch(this.baseUrl + url)
    if (!res.ok) throw new Error(`HTTP ${res.status}`)
    return res.json() as Promise<T>
  }
}
```

### infrastructure/todo-api.repository.ts

```ts
// Implementación de infraestructura del contrato de dominio
// import type { Todo } from '../domain/todo'
// import type { TodoRepository } from '../domain/todo.repository'
// import type { HttpClient } from './http-client'

type Todo = {
  userId: number
  id: number
  title: string
  completed: boolean
}

type TodoDto = Todo

export class TodoApiRepository /* implements TodoRepository */ {
  constructor(private readonly http: { get<T>(url: string): Promise<T> }) {}

  async findAll(): Promise<Todo[]> {
    const dtos = await this.http.get<TodoDto[]>('/todos?_limit=5')
    // Si se necesitara mapping DTO→dominio, este sería el lugar
    return dtos
  }
}
```

---

### application/get-todos.qry.ts

```ts
// Caso de uso (Application) que depende del contrato de dominio
// import type { Todo } from '../domain/todo'
// import type { TodoRepository } from '../domain/todo.repository'

type Todo = {
  userId: number
  id: number
  title: string
  completed: boolean
}

export class GetTodosQry {
  constructor(private readonly repo: { findAll(): Promise<Todo[]> }) {}
  handle(): Promise<Todo[]> {
    return this.repo.findAll()
  }
}
```

---

### container.ts

```ts
// Composición de dependencias fuera del dominio
// import { FetchHttpClient } from './infrastructure/http-client'
// import { TodoApiRepository } from './infrastructure/todo-api.repository'
// import { GetTodosQry } from './application/get-todos.qry'

class FetchHttpClient {
  constructor(private readonly baseUrl: string) {}
  async get<T>(url: string): Promise<T> {
    const res = await fetch(this.baseUrl + url)
    if (!res.ok) throw new Error(`HTTP ${res.status}`)
    return res.json() as Promise<T>
  }
}

class TodoApiRepository {
  constructor(private readonly http: { get<T>(url: string): Promise<T> }) {}
  async findAll() {
    return this.http.get<any[]>('/todos?_limit=5')
  }
}

class GetTodosQry {
  constructor(private readonly repo: { findAll(): Promise<any[]> }) {}
  handle() {
    return this.repo.findAll()
  }
}

const httpClient = new FetchHttpClient('https://jsonplaceholder.typicode.com')
const todoRepository = new TodoApiRepository(httpClient)

export const getTodosQry = new GetTodosQry(todoRepository)
```

---

### delivery/TodosView.vue

```vue
<template>
  <div class="space-y-2">
    <div class="flex items-center justify-between">
      <h2 class="font-semibold">Todos (Delivery)</h2>
      <button class="px-3 py-1.5 text-sm rounded bg-blue-600 text-white hover:bg-blue-700" @click="load">
        Volver a cargar
      </button>
    </div>

    <div v-if="loading" class="text-sm text-muted-foreground">Cargando...</div>
    <div v-else-if="error" class="text-sm text-red-600">{{ error }}</div>

    <ul v-else class="list-disc pl-5 space-y-1">
      <li v-for="todo in todos" :key="todo.id" class="text-sm">
        <span :class="{ 'line-through text-muted-foreground': todo.completed }">{{ todo.title }}</span>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
// import { ref, onMounted } from 'vue'
// import type { Todo } from '../domain/todo'
// import { getTodosQry } from '../container'
import { ref, onMounted } from 'vue'

type Todo = {
  userId: number
  id: number
  title: string
  completed: boolean
}

const todos = ref<Todo[]>([])
const loading = ref(false)
const error = ref<string | null>(null)

async function load() {
  loading.value = true
  error.value = null
  try {
    // En la implementación real: todos.value = await getTodosQry.handle()
    const res = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=5')
    if (!res.ok) throw new Error(`HTTP ${res.status}`)
    todos.value = await res.json()
  } catch (e) {
    error.value = e instanceof Error ? e.message : String(e)
  } finally {
    loading.value = false
  }
}

onMounted(load)
</script>
```

---

## Puntos clave de la solución

- El dominio no depende de ninguna librería ni detalle técnico.
- Application orquesta el trabajo usando contratos del dominio, sin conocer la infraestructura concreta.
- Infrastructure contiene implementaciones técnicas (HTTP) y mapeos.
- Delivery usa los casos de uso desde la UI. El wiring de dependencias se hace en un contenedor aparte.

## Siguientes pasos (opcional)

- Añadir middlewares al `HttpClient` (logging, retries, auth).
- Proveer una implementación en memoria de `TodoRepository` para tests.
- Extender con un `GetTodoByIdQry` u operaciones de escritura (Commands).
